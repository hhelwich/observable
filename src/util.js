// Binds a function to a context
// :: (->, {}) -> ->
let bind = (fn, context) => {
  return function() {
    return fn.apply(context, arguments);
  };
};

// Aliases
let _console = console;
let log = bind(_console.log, _console);
let error = bind(_console.error, _console);

let { slice, push } = Array.prototype;

// Returns true if the given value is of type boolean and is true.
// * -> boolean
const isTrue = value => value === true;

// Function that does nothing
// :: ->
const nop = () => {};

// A function to be called on the start of each queue message generated by this type.
// Can e.g. be used for debugging.
// :: ->
let onNext = nop;

// Add the given function to the message queue.
// :: (->) ->
const async = f => {
  setTimeout(() => {
    onNext();
    return f();
  }, 0);
};

// Returns `true` if the given value is a function.
// :: * -> boolean
const isFunc = f => typeof f === 'function';

// Returns a function. A function input is returned directly, Other values will result in a function that does nothing.
// :: * -> ->
const toFunc = f => isFunc(f) ? f : nop;

// Convert an argument object to an array.
// :: Arguments -> [*]
const toArray = args => slice.call(args, 0);

// Shallow copy an array.
// :: [*] -> [*]
const copyArray = array => array.slice();

// Appends content of second array to the end of the first array. Returns the changed first array.
// :: ([*], [*]) -> [*]
const appendArray = (a1, a2) => {
  push.apply(a1, a2);
  return a1;
};

// Returns the number of own key/value pairs in the given object.
// :: {} -> number
let objLength = (obj) => {
  return (Object.keys(obj)).length;
};

// Returns true if the given object has no own key/value pair.
// :: {} -> boolean
let isEmpty = (obj) => {
  return objLength(obj) === 0;
};
