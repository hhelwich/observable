// Binds a function to a context
// :: (->, {}) -> ->
const bind = (fn, context) => {
  return function() {
    return fn.apply(context, arguments);
  };
};

// Aliases
const _console = console;
const log = bind(_console.log, _console);
const error = bind(_console.error, _console);

const { slice, push } = Array.prototype;

// Returns true if the given value is of type boolean and is true.
// * -> boolean
const isTrue = value => value === true;

// Function that does nothing
// :: ->
const nop = () => {};

// A function to be called on the start of each queue message generated by this type.
// Can e.g. be used for debugging.
// :: ->
let onNext = nop;

// Add the given function to the message queue.
// :: (->) ->
const async = f => {
  setTimeout(() => {
    onNext();
    return f();
  }, 0);
};

// Returns `true` if the given value is a function.
// :: * -> boolean
const isFunc = f => typeof f === 'function';

// Returns a function. A function input is returned directly, Other values will result in a function that does nothing.
// :: * -> ->
const toFunc = f => isFunc(f) ? f : nop;

// Convert an argument object to an array.
// :: Arguments -> [*]
const toArray = args => slice.call(args, 0);

// Shallow copy an array.
// :: [*] -> [*]
const copyArray = array => array.slice();

// Appends content of second array to the end of the first array. Returns the changed first array.
// :: ([*], [*]) -> [*]
const appendArray = (a1, a2) => {
  push.apply(a1, a2);
  return a1;
};

// Returns the number of own key/value pairs in the given object.
// :: {} -> number
const objLength = obj => Object.keys(obj).length;

// Returns true if the given object has no own key/value pair.
// :: {} -> boolean
const isEmpty = obj => objLength(obj) === 0;

// Iterate key/value pairs of an object
// :: ((string -> *), ((string, *) ->)) ->
const iterate = (obj, callback) => {
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      callback(key, obj[key]);
    }
  }
};
